---
title: "Cerdeira_Diiuorio_TP4"
output: pdf_document
date: "2025-05-28"

---

```{r, echo = FALSE}
set.seed(1234)
datos_historicos = read.csv("datos_historicos.csv")$play.delay
datos_nueva_version = read.csv("datos_nueva_version.csv")$play.delay

```

## Ejercicio 1
### (a)

```{r, echo = FALSE}
media_muestral <- round(mean(datos_historicos),2)
var_muestral <- round(var(datos_historicos),2)

``` 

La **media muestral** de los datos historicos es **`r media_muestral`**.

La **varianza muestral** de los datos historicos es **`r var_muestral`**.

### (b)

``` {r, echo = FALSE}
hist(datos_historicos, prob = TRUE, breaks=30 ,col = "lightblue", main = "Histograma de densidad de datos historicos")
curve(dnorm(x, mean = media_muestral, sd = sqrt(var_muestral)), lwd = 2, lty = 2, add = TRUE, col = "darkred")

```

Los datos parecen distribuirse de forma normal.

## Ejercicio 2



Primero definimos:


* \(\mu_0 \) = media del "play-delay" de la versión anterior = 41.9847 

* \(\sigma_0^2\) = varianza del "play-delay" de la versión anterior = 52.4325




Ahora definimos:

$$ X_i = \text{El "play-delay" del i-ésimo usuario evaluado con la nueva versión. }\space 1\leq i\leq 200  $$



Y contamos con la siguiente distribución de nuestra muestra:

$$ \space X_1, ..., X_{200} \sim \mathcal{N}(\mu, {52.43}) \text{ iid} \\$$

Donde:

$$ \mu = \text{media del ``play-delay'' }   \\$$

```{r, echo = FALSE}

mu_estimado = round(mean(datos_nueva_version),2)

```


Para estimar \(\mu\) vamos calcular la **media muestral** de la muestra con los 200 nuevos usuarios.

La estimación de \(\mu\) es:  

$$ \hat{\mu} = \overline{X} = 42.99 \\$$

## Ejercicio 3

### (a) 



Proponemos las siguientes Hipótesis Nula e Hipótesis Alternativa


$$ H_0: \mu \leq \mu_0\quad vs.\quad H_1: \mu > \mu_0\quad \\$$ 


Es decir,
$$ H_0: \mu \leq 41.98 \quad\text{vs}.\quad  H_1: \mu > 41.98 \\$$


Para simplificar el problema, suponemos:
$$ H_0: \mu = 41.98  \\$$

Esto se puede hacer ya que el caso límite de \(H_0\) es cuando \(\mu\) = 41.9847. Por lo tanto, si puedo rechazar esa \(H_0\) entonces puedo rechazar también todos los valores de 

$$ \mu \leq 41.98 \\$$


Por ende, las hipótesis quedarían así:


$$ H_0: \mu = 41.98 \quad\text{vs}.\quad  H_1: \mu > 41.98 \\$$

**Estadístico:** 


Para hallar el estadístico partimos del estimador de \(\mu\):  

$$ \hat{\mu} = \overline{X} $$
Asumimos distribución de  \(\overline{X}\) bajo  \(H_{0}\):

$$ \overline{X} \sim \mathcal{N}(41.98, \frac{52.43}{200}) \quad \text{bajo } H_0 \\$$

Lo estandarizamos:

$$T=\frac{\overline{X}-41.98}{\sqrt{52.43 / 200}} \sim \mathcal{N}(0, 1) \quad \text{bajo } H_0 \\$$

T es nuestro estadístico. Nos sirve porque es una función de la muestra aleatoria y tiene distribución conocida bajo \(H_0\). 

### (b)

$$ \alpha = 0.05 \\$$



Vamos a rechazar \(H_{0}\) cuando \(\overline{X}>C\) donde C es un número tal que:
$$ \quad \alpha = P(EI) = P(\text{Rechazar } H_0 | H_0  \text{ es V}) = P(\overline{X}>C| H_0 \text{ es V})  \\$$
$$ \implies \text{Queremos C tal que } P(\overline{X}>C|H_0 \text{ es V}) \\$$

$$ P(\overline{X}>C|H_0 \text{ es V}) = {P(\frac{\overline{X}-41.98}{\sqrt{52.43 / 200}} > \frac{C-41.98}{\sqrt{52.43 / 200}} \space| H_0 \text{ es V })} \\$$



$$ como \quad \frac{\overline{X}-41.98}{\sqrt{52.43 / 200}}  \sim \mathcal{N}(0, 1) \quad \text{bajo } H_0 \\$$

Entonces lo llamamos Z ya que 

$$ Z \sim \mathcal{N}(0, 1) \\$$

Por lo tanto, 


$$ {P(\frac{\overline{X}-41.98}{\sqrt{52.43 / 200}} > \frac{C-41.98}{\sqrt{52.43 / 200}} \space| H_0 \text{ es V })} = P(Z > q) \\$$

donde 

$$ q = \space \frac{C-41.98}{\sqrt{52.43 / 200}}  \\$$


Según la Hipótesis Alternativa, decidimos rechazar \(H_0\) cuando:  

$$  T = \frac{\overline{X}-41.98}{\sqrt{52.43 / 200}} > q \\$$


$$ \text{Queremos }  q \space / P(Z > q) = \alpha = 0.05 \\$$

``` {r}
alpha <- 0.05
q <- qnorm(1-alpha, mean = 0, sd = 1)
```

```{r, echo = FALSE}
media <- 0
desvio <- 1
x <- seq(-4, 4, length = 1000)
y <- dnorm(x, mean = media, sd = desvio)

# Graficamos la curva normal
plot(x, y, type = "l", lwd = 2, col = "blue",
     xlab = "N(0,1)", ylab = "", 
     main = paste("Área =", alpha, "a derecha de q"))

# Sombrear el área correspondiente
x_somb <- seq( q, 4, length = 1000)
y_somb <- dnorm(x_somb, mean = media, sd = desvio)

polygon(c(x_somb, rev(x_somb)), 
        c(y_somb, rep(0, length(y_somb))), 
        col = rgb(1, 0, 0, 0.3), border = NA)

# Línea vertical en q
abline(v = q, col = "red", lwd = 2, lty = 2)
text(q, dnorm(q), labels = sprintf("q"), pos = 4, col = "red")

```





Entonces, q es un cuantil tal que me deja área \(\alpha\) = 0.05 a derecha o área 1 - \(\alpha\) = 0.95 a izquierda .



$$ \text{Por lo tanto } q = Z_{\alpha} = Z_{0.05} \\$$


Nuestra Región de Rechazo quedaría 

$$ R = \{ T > Z_{0.05}\} \\$$

Por la tabla de una Normal Estándar, podemos ver que 


$$ q = Z_{0.05} = 1.64 \\$$



Como resultado, la Región de Rechazo para este test es:


$$ R = \{ T > 1.64\} \\$$


## Ejercicio 4

### (a)


Para utilizar el test construido, el primer paso es calcular el promedio de los valores de la muestra "datos nueva versión". Una vez calculado, evaluamos nuestro estadístico observado. Si este pertenece en la Región de Rechazo, rechazamos \(H_0\). En el caso de no pertenecer a la región, no confirmamos que \(H_0\) sea verdadera sino que no tenemos la suficiente evidencia para rechazarla.  

Como vimos antes:

$$ \hat{\mu} = \overline{X} =  42.99 \\$$
Ahora, buscamos al estadístico observado de esta muestra. 

$$  T_{obs} = \frac{\overline{X_{obs}}-41.98}{\sqrt{52.43 / 200}} \\$$

$$  T_{obs} = \frac{42.99-41.98}{\sqrt{52.43 / 200}} = 1.97\\$$

```{r, echo = FALSE}

Tobs <- round((42.99 - 41.98) / sqrt(52.43/200), 2)

```

Mi estadístico observado es \(T_{obs}\) = `r Tobs`

Como podemos ver, el estadístico observado pertenece a la región de rechazo. Tenemos suficiente evidencia para rechazar \(H_0\) porque `r Tobs` > 1.64

Con esta evidencia rechazamos la actualización ya que aumenta el "play-delay", es decir, la esperanza del "play-delay" con la versión nueva es mayor a la actual, y es por eso que enviamos el código a revisión. 


### (b)

```{r, echo = FALSE}

alpha_1 <- 0.01
alpha_2 <- 0.1

q1 <- qnorm(1 - alpha_1, mean = 0, sd = 1)
q2 <- qnorm(1 - alpha_2, mean = 0, sd = 1)


```

#### \(\alpha\)=0.01


$$ P(EI) = P(\text{Rechazar } H_0 | H_0 \text{ es V}) = 0.01 \\$$

La Región de Rechazo con \(\alpha\) = 0.01 será:

$$ R = \{T > Z_{\alpha}\} = \{T > Z_{0.01}\} = \{T > 2.33\}  \\$$
El cuantil \(Z_{0.01}\) deja menos área a la derecha que el cuantil \(Z_{0.05}\). Esto implica que el primero está gráficamente a derecha del segundo (\(Z_{0.05}\) < \(Z_{0.01}\)).  


#### \(\alpha\)=0.1

$$ P(EI) = P(\text{Rechazar } H_0 | H_0 \text{ es V}) = 0.1 \\$$
La Región de Rechazo con \(\alpha\) = 0.1 será:

$$ R = \{T > Z_{\alpha}\} = \{T > Z_{0.1}\} = \{T > 1.28\} \\$$

El cuantil \(Z_{0.1}\) deja más área a la derecha que el cuantil \(Z_{0.05}\). Esto implica que el primero está gráficamente a izquierda del segundo (\(Z_{0.1}\) < \(Z_{0.05}\)).  


El \(\alpha\) desplaza el punto de corte para la Región de Rechazo. A mayor \(\alpha\), menor es el punto de corte del cual arranca la Región de Rechazo. Aplicado a este test, a mayor \(\alpha\), mando más seguido actualizaciones a auditar, ya que el estadístico observado puede ser menor para rechazar \(H_0\) y decir que el "play-delay" de la nueva versión es mayor al actual. 



### (C)

```{r, echo= FALSE}

alfas <- seq(0.01, 0.10, by = 0.01)

z_crit  <- numeric(length(alfas))   # un vector numérico vacío de la misma longitud que 'alfas'
decision <- character(length(alfas)) # un vector de texto (caracteres) vacío

for(i in 1:length(alfas)){
  
  z_crit[i] <- qnorm(1-alfas[i])
  
  if(Tobs >= z_crit[i]){
    decision[i] <- "Rechazo H0"
  } else {
    decision[i] <- "No Rechazo H0"
  }
}

# Armo un data.frame con las tres columnas
tabla <- data.frame(
  alpha    = alfas,
  z_crit   = round(z_crit, 3),  # redondeo a 3 decimales para que quede prolijo
  decision = decision
)

print(tabla)

```

```{r, echo = FALSE}
# plot vacío con ejes y densidad
plot(NA, xlim = c(-4, 4), ylim = c(0, dnorm(0)), 
     xlab = "Valor de Z", ylab = "Densidad", 
     main = "Normal Estándar con cortes y T_obs")

# dibujo la curva de la Normal estándar
curve(dnorm(x), from = -4, to = 4, add = TRUE, 
      col = "orange", lwd = 2)

# --------------------------------------------
# 3) Agrego líneas punteadas para cada z_crítico
# --------------------------------------------
for (zc in z_crit) {
  abline(v = zc, lty = 2, col = "orange", lwd = 1)
}

# --------------------------------------------
# 4) Agrego la línea gruesa para z_obs
# --------------------------------------------
abline(v = Tobs, col = "black", lwd = 2)

# --------------------------------------------
# 5) Agrego leyenda para aclarar
# --------------------------------------------
legend("topright", 
       legend = c("Normal Estándar", 
                  paste0("T-obs = ", round(Tobs, 3))),
       col    = c("orange", "black"),
       lty    = c(1, 1),
       lwd    = c(2, 2),
       bty    = "n")
```


